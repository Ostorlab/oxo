"""Unit tests for Report Vulnerability Mixin."""

from typing import List

import pytest

from ostorlab.agent import agent
from ostorlab.agent import definitions as agent_definitions
from ostorlab.agent.kb import kb as knowledge_base
from ostorlab.agent.mixins import agent_report_vulnerability_mixin
from ostorlab.runtimes import definitions as runtime_definitions


class TestAgent(agent.Agent, agent_report_vulnerability_mixin.AgentReportVulnMixin):
    pass


def testSendVulnerabilityMessage_whenKbEntryIsValid_emitVulnerabilityMessage(
    agent_mock: List[object],
) -> None:
    """Prepares & emit vulnerability message with all the information from the Knowledge base."""
    agent_definition = agent_definitions.AgentDefinition(
        name="some_name", out_selectors=["v3.report.vulnerability"]
    )
    agent_settings = runtime_definitions.AgentSettings(key="some_key")
    report_vul_mixin = TestAgent(agent_definition, agent_settings)
    report_vul_mixin.report_vulnerability(
        entry=knowledge_base.KB.VIRUSTOTAL_SCAN,
        technical_detail="some_technical_detail",
        risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
        dna="some_dna",
    )

    assert len(agent_mock) == 1
    assert agent_mock[0].selector == "v3.report.vulnerability"
    assert agent_mock[0].data["short_description"] == "VirusTotal Malware analysis."
    assert agent_mock[0].data["privacy_issue"]
    assert agent_mock[0].data["security_issue"]
    assert agent_mock[0].data["risk_rating"] == "HIGH"
    assert agent_mock[0].data["references"] == [
        {"title": "Virustotal", "url": "https://www.virustotal.com/"}
    ]


# parametrize with a list of fixtures
@pytest.mark.parametrize(
    "vulnerability_location_fixture,asset_name",
    [
        ("vulnerability_location_android_aab", "android_aab"),
        ("vulnerability_location_ios_store", "ios_store"),
        ("vulnerability_location_ipv4", "ipv4"),
        ("vulnerability_location_ipv6", "ipv6"),
        ("vulnerability_location_domain_name", "domain_name"),
        ("vulnerability_location_android_store", "android_store"),
        ("vulnerability_location_ios_ipa", "ios_ipa"),
        ("vulnerability_location_link_asset", "link"),
        ("vulnerability_location_file", "file"),
        ("vulnerability_location_android_apk", "android_apk"),
    ],
)
def testSendVulnerabilityMessage_withVulnerabilityLocation_emitVulnerabilityMessageWithProperData(
    vulnerability_location_fixture,
    asset_name,
    request,
    agent_mock: List[object],
) -> None:
    """Prepares & emit vulnerability message with all the information from the Knowledge base."""
    agent_definition = agent_definitions.AgentDefinition(
        name="some_name", out_selectors=["v3.report.vulnerability"]
    )
    agent_settings = runtime_definitions.AgentSettings(key="some_key")
    report_vul_mixin = TestAgent(agent_definition, agent_settings)
    report_vul_mixin.report_vulnerability(
        vulnerability_location=request.getfixturevalue(vulnerability_location_fixture),
        entry=knowledge_base.KB.VIRUSTOTAL_SCAN,
        technical_detail="some_technical_detail",
        risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
        dna="some_dna",
    )

    assert len(agent_mock) == 1
    assert agent_mock[0].selector == "v3.report.vulnerability"
    assert agent_mock[0].data["vulnerability_location"][asset_name] is not None
    assert agent_mock[0].data["vulnerability_location"]["metadata"] is not None
    assert (
        agent_mock[0].data["vulnerability_location"]["metadata"][0]["type"]
        == agent_report_vulnerability_mixin.MetadataType.FILE_PATH.name
    )
    assert len(agent_mock[0].data["vulnerability_location"]["metadata"]) == 4


def testSendVulnerabilityMessage_withVulnerabilityLocationWithoutAsset_emitVulnerabilityMessageWithProperData(
    agent_mock: List[object],
) -> None:
    """Prepares & emit vulnerability message with all the information from the Knowledge base."""
    agent_definition = agent_definitions.AgentDefinition(
        name="some_name", out_selectors=["v3.report.vulnerability"]
    )
    agent_settings = runtime_definitions.AgentSettings(key="some_key")
    report_vul_mixin = TestAgent(agent_definition, agent_settings)
    report_vul_mixin.report_vulnerability(
        vulnerability_location=agent_report_vulnerability_mixin.VulnerabilityLocation(
            metadata=[
                agent_report_vulnerability_mixin.VulnerabilityLocationMetadata(
                    metadata_type=agent_report_vulnerability_mixin.MetadataType.LOG,
                    value="kernel[0] <Notice>: bpf0 attached to pktap0",
                )
            ]
        ),
        entry=knowledge_base.KB.VIRUSTOTAL_SCAN,
        technical_detail="some_technical_detail",
        risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
        dna="some_dna",
    )

    assert len(agent_mock) == 1
    assert agent_mock[0].selector == "v3.report.vulnerability"
    assert agent_mock[0].data["vulnerability_location"]["metadata"] is not None
    assert (
        agent_mock[0].data["vulnerability_location"]["metadata"][0]["type"]
        == agent_report_vulnerability_mixin.MetadataType.LOG.name
    )
    assert (
        agent_mock[0].data["vulnerability_location"]["metadata"][0]["value"]
        == "kernel[0] <Notice>: bpf0 attached to pktap0"
    )


def testSendVulnerabilityMessage_whenKbEntryIsValidAndRiskIsCritical_emitVulnerabilityMessage(
    agent_mock: list[object],
) -> None:
    """Prepares & emit vulnerability message with all the information from the Knowledge base."""
    agent_definition = agent_definitions.AgentDefinition(
        name="some_name", out_selectors=["v3.report.vulnerability"]
    )
    agent_settings = runtime_definitions.AgentSettings(key="some_key")
    report_vul_mixin = TestAgent(agent_definition, agent_settings)
    report_vul_mixin.report_vulnerability(
        entry=knowledge_base.KB.VIRUSTOTAL_SCAN,
        technical_detail="some_technical_detail",
        risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
        dna="some_dna",
    )

    assert len(agent_mock) == 1
    assert agent_mock[0].selector == "v3.report.vulnerability"
    assert agent_mock[0].data["short_description"] == "VirusTotal Malware analysis."
    assert agent_mock[0].data["privacy_issue"]
    assert agent_mock[0].data["security_issue"]
    assert agent_mock[0].data["risk_rating"] == "CRITICAL"
    assert agent_mock[0].data["references"] == [
        {"title": "Virustotal", "url": "https://www.virustotal.com/"}
    ]


def testSendVulnerabilityMessage_whenKbEntryIsValidWithCategories_emitVulnerabilityMessage(
    agent_mock: list[object],
) -> None:
    """Prepares & emit vulnerability message with all the information from the Knowledge base."""
    agent_definition = agent_definitions.AgentDefinition(
        name="some_name", out_selectors=["v3.report.vulnerability"]
    )
    agent_settings = runtime_definitions.AgentSettings(key="some_key")
    report_vul_mixin = TestAgent(agent_definition, agent_settings)
    report_vul_mixin.report_vulnerability(
        entry=knowledge_base.KB.WEB_XSS,
        technical_detail="some_technical_detail",
        risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
        dna="some_dna",
    )

    assert len(agent_mock) == 1
    assert agent_mock[0].selector == "v3.report.vulnerability"
    assert agent_mock[0].data["risk_rating"] == "CRITICAL"
    assert agent_mock[0].data["category_groups"] == [
        {"key": "OWASP_ASVS_L1", "categories": ["V5_2_1", "V5_3_1", "V13_1_1"]},
        {
            "key": "OWASP_ASVS_L2",
            "categories": ["V5_2_1", "V1_5_4", "V5_3_1", "V13_1_1"],
        },
        {
            "key": "OWASP_ASVS_L3",
            "categories": ["V5_2_1", "V1_5_4", "V5_3_1", "V13_1_1"],
        },
        {
            "key": "PCI_STANDARDS",
            "categories": ["REQ_2_2", "REQ_6_2", "REQ_6_3", "REQ_6_4", "REQ_11_3"],
        },
    ]
