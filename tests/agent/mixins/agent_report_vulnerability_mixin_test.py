"""Unit tests for Report Vulnerability Mixin."""

from typing import List

import pytest

from ostorlab.agent import agent
from ostorlab.agent import definitions as agent_definitions
from ostorlab.agent.kb import kb as knowledge_base
from ostorlab.agent.mixins import agent_report_vulnerability_mixin
from ostorlab.runtimes import definitions as runtime_definitions


class TestAgent(agent.Agent, agent_report_vulnerability_mixin.AgentReportVulnMixin):
    pass


def testSendVulnerabilityMessage_whenKbEntryIsValid_emitVulnerabilityMessage(
    agent_mock: List[object],
) -> None:
    """Prepares & emit vulnerability message with all the information from the Knowledge base."""
    agent_definition = agent_definitions.AgentDefinition(
        name="some_name", out_selectors=["v3.report.vulnerability"]
    )
    agent_settings = runtime_definitions.AgentSettings(key="some_key")
    report_vul_mixin = TestAgent(agent_definition, agent_settings)
    report_vul_mixin.report_vulnerability(
        entry=knowledge_base.KB.SECURE_VIRUSTOTAL_SCAN,
        technical_detail="some_technical_detail",
        risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
        dna="some_dna",
    )

    assert len(agent_mock) == 1
    assert agent_mock[0].selector == "v3.report.vulnerability"
    assert agent_mock[0].data["short_description"] == "VirusTotal Malware analysis."
    assert agent_mock[0].data["privacy_issue"] is False
    assert agent_mock[0].data["security_issue"] is False
    assert agent_mock[0].data["risk_rating"] == "HIGH"
    assert agent_mock[0].data["references"] == [
        {"title": "Virustotal", "url": "https://www.virustotal.com/"}
    ]


# parametrize with a list of fixtures
@pytest.mark.parametrize(
    "vulnerability_location_fixture,asset_name",
    [
        ("vulnerability_location_android_aab", "android_aab"),
        ("vulnerability_location_ios_store", "ios_store"),
        ("vulnerability_location_ipv4", "ipv4"),
        ("vulnerability_location_ipv6", "ipv6"),
        ("vulnerability_location_domain_name", "domain_name"),
        ("vulnerability_location_android_store", "android_store"),
        ("vulnerability_location_ios_ipa", "ios_ipa"),
        ("vulnerability_location_link_asset", "link"),
        ("vulnerability_location_file", "file"),
        ("vulnerability_location_android_apk", "android_apk"),
    ],
)
def testSendVulnerabilityMessage_withVulnerabilityLocation_emitVulnerabilityMessageWithProperData(
    vulnerability_location_fixture,
    asset_name,
    request,
    agent_mock: List[object],
) -> None:
    """Prepares & emit vulnerability message with all the information from the Knowledge base."""
    agent_definition = agent_definitions.AgentDefinition(
        name="some_name", out_selectors=["v3.report.vulnerability"]
    )
    agent_settings = runtime_definitions.AgentSettings(key="some_key")
    report_vul_mixin = TestAgent(agent_definition, agent_settings)
    report_vul_mixin.report_vulnerability(
        vulnerability_location=request.getfixturevalue(vulnerability_location_fixture),
        entry=knowledge_base.KB.SECURE_VIRUSTOTAL_SCAN,
        technical_detail="some_technical_detail",
        risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
        dna="some_dna",
    )

    assert len(agent_mock) == 1
    assert agent_mock[0].selector == "v3.report.vulnerability"
    assert agent_mock[0].data["vulnerability_location"][asset_name] is not None
    assert agent_mock[0].data["vulnerability_location"]["metadata"] is not None
    assert (
        agent_mock[0].data["vulnerability_location"]["metadata"][0]["type"]
        == agent_report_vulnerability_mixin.MetadataType.FILE_PATH.name
    )
    assert len(agent_mock[0].data["vulnerability_location"]["metadata"]) == 4


def testSendVulnerabilityMessage_withVulnerabilityLocationWithoutAsset_emitVulnerabilityMessageWithProperData(
    agent_mock: List[object],
) -> None:
    """Prepares & emit vulnerability message with all the information from the Knowledge base."""
    agent_definition = agent_definitions.AgentDefinition(
        name="some_name", out_selectors=["v3.report.vulnerability"]
    )
    agent_settings = runtime_definitions.AgentSettings(key="some_key")
    report_vul_mixin = TestAgent(agent_definition, agent_settings)
    report_vul_mixin.report_vulnerability(
        vulnerability_location=agent_report_vulnerability_mixin.VulnerabilityLocation(
            metadata=[
                agent_report_vulnerability_mixin.VulnerabilityLocationMetadata(
                    metadata_type=agent_report_vulnerability_mixin.MetadataType.LOG,
                    value="kernel[0] <Notice>: bpf0 attached to pktap0",
                )
            ]
        ),
        entry=knowledge_base.KB.SECURE_VIRUSTOTAL_SCAN,
        technical_detail="some_technical_detail",
        risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
        dna="some_dna",
    )

    assert len(agent_mock) == 1
    assert agent_mock[0].selector == "v3.report.vulnerability"
    assert agent_mock[0].data["vulnerability_location"]["metadata"] is not None
    assert (
        agent_mock[0].data["vulnerability_location"]["metadata"][0]["type"]
        == agent_report_vulnerability_mixin.MetadataType.LOG.name
    )
    assert (
        agent_mock[0].data["vulnerability_location"]["metadata"][0]["raw_value"]
        == "kernel[0] <Notice>: bpf0 attached to pktap0"
    )


def testSendVulnerabilityMessage_whenKbEntryIsValidAndRiskIsCritical_emitVulnerabilityMessage(
    agent_mock: list[object],
) -> None:
    """Prepares & emit vulnerability message with all the information from the Knowledge base."""
    agent_definition = agent_definitions.AgentDefinition(
        name="some_name", out_selectors=["v3.report.vulnerability"]
    )
    agent_settings = runtime_definitions.AgentSettings(key="some_key")
    report_vul_mixin = TestAgent(agent_definition, agent_settings)
    report_vul_mixin.report_vulnerability(
        entry=knowledge_base.KB.SECURE_VIRUSTOTAL_SCAN,
        technical_detail="some_technical_detail",
        risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
        dna="some_dna",
    )

    assert len(agent_mock) == 1
    assert agent_mock[0].selector == "v3.report.vulnerability"
    assert agent_mock[0].data["short_description"] == "VirusTotal Malware analysis."
    assert agent_mock[0].data["privacy_issue"] is False
    assert agent_mock[0].data["security_issue"] is False
    assert agent_mock[0].data["risk_rating"] == "CRITICAL"
    assert agent_mock[0].data["references"] == [
        {"title": "Virustotal", "url": "https://www.virustotal.com/"}
    ]


def testSendVulnerabilityMessage_whenKbEntryIsValidWithCategories_emitVulnerabilityMessage(
    agent_mock: list[object],
) -> None:
    """Prepares & emit vulnerability message with all the information from the knowledge base."""
    agent_definition = agent_definitions.AgentDefinition(
        name="some_name", out_selectors=["v3.report.vulnerability"]
    )
    agent_settings = runtime_definitions.AgentSettings(key="some_key")
    report_vul_mixin = TestAgent(agent_definition, agent_settings)

    report_vul_mixin.report_vulnerability(
        entry=knowledge_base.KB.WEB_XSS,
        technical_detail="some_technical_detail",
        risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
        dna="some_dna",
    )

    assert len(agent_mock) == 1
    assert agent_mock[0].selector == "v3.report.vulnerability"
    assert agent_mock[0].data["risk_rating"] == "CRITICAL"
    assert agent_mock[0].data["category_groups"] == [
        {"key": "OWASP_ASVS_L1", "categories": ["V5_2_1", "V5_3_1", "V13_1_1"]},
        {
            "key": "OWASP_ASVS_L2",
            "categories": ["V5_2_1", "V1_5_4", "V5_3_1", "V13_1_1"],
        },
        {
            "key": "OWASP_ASVS_L3",
            "categories": ["V5_2_1", "V1_5_4", "V5_3_1", "V13_1_1"],
        },
        {
            "key": "PCI_STANDARDS",
            "categories": ["REQ_2_2", "REQ_6_2", "REQ_6_3", "REQ_6_4", "REQ_11_3"],
        },
        {
            "key": "SOC2_CONTROLS",
            "categories": [
                "CC_2_1",
                "CC_4_1",
                "CC_7_1",
                "CC_7_2",
                "CC_7_4",
                "CC_7_5",
            ],
        },
    ]


def testFrameToProtoDict_whenAllFieldsAreSet_returnsCompleteDict() -> None:
    """Test that to_proto_dict returns a complete dictionary when all fields are set."""
    frame = agent_report_vulnerability_mixin.Frame(
        function_name="test_func",
        class_name="TestClass",
        package_name="test.package",
    )

    proto_dict = frame.to_proto_dict()

    assert proto_dict == {
        "function_name": "test_func",
        "class_name": "TestClass",
        "package_name": "test.package",
    }


def testCallTraceToProtoDict_whenAllFieldsAreSet_returnsCompleteDict() -> None:
    """Test that to_proto_dict returns a complete dictionary when all fields are set."""
    frame1 = agent_report_vulnerability_mixin.Frame(
        function_name="test_func1",
        class_name="TestClass1",
        package_name="test.package1",
    )
    frame2 = agent_report_vulnerability_mixin.Frame(
        function_name="test_func2",
        class_name="TestClass2",
        package_name="test.package2",
    )

    call_trace = agent_report_vulnerability_mixin.CallTrace(
        frames=[frame1, frame2],
    )

    proto_dict = call_trace.to_proto_dict()

    assert proto_dict == {
        "frames": [
            {
                "function_name": "test_func1",
                "class_name": "TestClass1",
                "package_name": "test.package1",
            },
            {
                "function_name": "test_func2",
                "class_name": "TestClass2",
                "package_name": "test.package2",
            },
        ],
    }


def testSendVulnerabilityMessage_withVulnMetadataContainsCallTraceDetails_emitVulnerabilityMessageWithProperData(
    agent_mock: List[object], call_trace: agent_report_vulnerability_mixin.CallTrace
) -> None:
    """Prepares & emit vulnerability message where the metadata contains a syackstrace instance."""
    agent_definition = agent_definitions.AgentDefinition(
        name="some_name", out_selectors=["v3.report.vulnerability"]
    )
    agent_settings = runtime_definitions.AgentSettings(key="some_key")
    report_vul_mixin = TestAgent(agent_definition, agent_settings)
    report_vul_mixin.report_vulnerability(
        vulnerability_location=agent_report_vulnerability_mixin.VulnerabilityLocation(
            metadata=[
                agent_report_vulnerability_mixin.VulnerabilityLocationMetadata(
                    metadata_type=agent_report_vulnerability_mixin.MetadataType.CALL_TRACE,
                    value=call_trace,
                )
            ]
        ),
        entry=knowledge_base.KB.SECURE_VIRUSTOTAL_SCAN,
        technical_detail="some_technical_detail",
        risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
        dna="some_dna",
    )

    assert len(agent_mock) == 1
    assert agent_mock[0].selector == "v3.report.vulnerability"
    metadata = agent_mock[0].data["vulnerability_location"]["metadata"]
    assert len(metadata) == 1
    assert metadata[0]["type"] == "CALL_TRACE"
    assert metadata[0]["calltrace"] is not None
